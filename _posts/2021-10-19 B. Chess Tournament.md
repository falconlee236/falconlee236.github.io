---
layout: single

title: "B. Chess Tournament"
excerpt: "Educational Codeforces Round 113 (Rated for Div. 2)"

date: 2021-10-19 19:38:39 +0900
last_modified_at: 2021-10-19 19:38:39 +0900 # sitemap.xml에서 사용됨

author_profile: true # 왼쪽부분 프로필을 띄울건지
sidebar:
  nav: "main"

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5 # 투명도

categories: 
  - Codeforces

tags: 
    - Codeforces
    - Educational Codeforces Round 113 (Rated for Div. 2)

use_math: true
comments: true
# table of contents
toc: true # 오른쪽 부분에 목차를 자동 생성해준다.
toc_label: "목차" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---

## 문제 설명  
$n$명의 체스 선수가 참여할 체스 토너먼트가 곧 시작합니다! 모든 참가자는 다른 모든 참가자와 한번씩 게임을 진행해야 합니다. 한 경기가 끝나면 한 사람이 이기고, 다른 사람이 지는 경우와 두 참가자 모두 비기는 경우가 생깁니다.  
 
각 참가자는 자신만의 성향을 가지고 있는데, 그 성향은 다음 중 하나입니다.  
1. 자신이 참여한 모든 게임에 지기 싫어하는 사람(즉 한번이라도 지지 않고 토너먼트를 종료해야함.)  
2. 최소 1번의 경기에 승리하고 싶어하는 사람  

우리가 할 일은 모든 참가자의 성향을 만족하는 토너먼트 결과표가 존재하는지 아닌지 결정을 하는 것입니다. 만약 다양한 결과표가 존재하면 그것중 하나를 출력한다. 만약 존재하지 않는다면 불가능하다고 말해야 합니다.  

__Input__  
첫번째 줄에는 테스트 케이스의 개수 $t$가 주어진다. $(1 \le t \le 200)$

각 테스트케이스의 첫번째 줄에는 체스 참가자 수 $n$이 주어진다. $(2 \le n \le 50)$  

각 테스트케이스의 두번째 줄에는 $n$자리로 이루어진 문자열 $s(|s| = n, s_i \in \{1, 2\})$가 주어진다. 만약 $s_i = 1$ 이면 $i$번째 참가자는 1번 성향을 가지고 있고, 그렇지 않으면 2번 성향을 가지고 있다.  

__Output__  
각 테스트 케이스마다 다음 양식에 따라 출력한다.  
첫번째 줄에는 모든 참가자의 성향을 충족하지 못하면 "NO"를 출력한다.  
그렇지 않으면 "YES"를 출력한다. 그리고 다음 $n$번째 줄에는 $n \times n$크기의 행렬을 출력한다.  
행렬의 $i$번째 행과 $j$번째 열에 속한 원소는 다음에 설명할 경우 중 하나를 만족해야한다.  
* 만약 $i$번째 참가자가 승리하고, $j$번째 참가자가 패배하면 => +
* 만약 $i$번째 참가자가 패배하고, $j$번째 참가자가 승리하면 => -
* 만약 $i$번째 참가자와 $j$번째 참가자가 비겼으면 => =
* 만약 $i = j$이면 => X  

__Example__  
_input_  
3  
3  
111  
2  
21  
4  
2122  
  

_output_  
YES  
X==  
=X=  
==X  
NO  
YES  
X--+  
+X++  
+-X-  
--+X  
  


## 문제 접근
__사용한 알고리즘__: 구현, 구성적  
걸린 시간 : 00:21  
virtual contest에서 1시간 정도 걸려서 겨우겨우 푼 문제이다. 문제접근방식은 contest를 끝나고 editorial을 보니까 맞았는데, 이 접근 방식을 생각하기 위해서 


## 정답 코드  
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	int t; cin >> t;
	while(t--){
	    int n; cin >> n;
	    char cnt[n];
	    vector<int> v;
	    for(int i = 0; i < n; i++){
	        cin >> cnt[i];
	        if(cnt[i] == '2') v.push_back(i);
	    }
	    
	    if(v.size() == 1 || v.size() == 2) cout << "NO" << "\n";
	    else{
	        cout << "YES" << "\n";
	        vector<string> arr(n, string(n, '='));
	        for(int i = 0; i < n; i++) arr[i][i] = 'X';
	        
	        for(int i = 0; i < v.size(); i++){
	            int cur = v[i], next = v[(i + 1) % v.size()];
	            arr[cur][next] = '+';
	            arr[next][cur] = '-';
	        }
	        
	        for(int i = 0; i < n; i++) cout << arr[i] << "\n";
	    }
	}
	return 0;
}
```  
{%- include blog_post_comments.html -%}
