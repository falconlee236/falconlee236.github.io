---
layout: single

title: "C. Book"
excerpt: "Codeforces Round #743 (Div. 2)"

date: 2021-09-26 20:14:36 +0900
last_modified_at: 2021-09-26 20:14:36 +0900 # sitemap.xml에서 사용됨

author_profile: true # 왼쪽부분 프로필을 띄울건지
sidebar:
  nav: "main"

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5 # 투명도

categories: 
  - Codeforces

tags: 
    - Codeforces
    - Codeforces Round #743 (Div. 2)

# table of contents
toc_label: "목차" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---  
# 문제 설명  
$n$개 챕터로 이루어진 책이 있다.  
각 챕터는 이해하기 위해서 필요한 다른 챕터의 목록이 있다. 이 목록에 있는 모든 챕터를 읽어야만 이 챕터를 읽고 이해할 수 있다.  
현재 당신은 아무 챕터도 이해하지 못한상태이다. 당신은 처음부터 끝까지 책을 반복해서 읽을 것이고, 책에 있는 모든 챕터를 다 이해할때까지 이 과정을 반복한다. 당신이 한 챕터를 읽을때, 그 챕터를 이해하기 위한 목록에 있는 챕터를 모두 읽지 않았다면 당신이 읽은 챕터는 이해한 것이 아니다. 
책에 있는 모든 챕터를 이해하기 위해서 반복해서 읽어야하는 책의 최소 횟수를 구해야한다. 혹은 책을 몇번이라도 읽더라도 모든 챕터를 절대로 이해할 수 없는지 결정해야한다.  

__입력__  
이 문제는 다수의 테스트케이스가 주어진다. 첫번째 줄에는 테스트케이스의 수 $t$가 주어진다. $(1 \le t \le 2\times10^4)$  
각 테스트케이스의 첫번째 줄은 
# 문제 접근  
사용한 알고리즘: 인접리스트, 그래프 이론, 집합  
걸린 시간: 00:18  


# 소스 코드
```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int main(){
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        vector<vector<int>> g(n + 1);
        vector<int> cnt(n + 1);
        set<int> s;
        for(int i = 1; i <= n; i++){
            int num; cin >> num;
            if(!num) s.insert(i);
            cnt[i] = num;
            while(num--){
                int pre; cin >> pre;
                g[pre].push_back(i);
            }
        }
        int total = n;
        int page = 1;
        int ans = 1;
        while(total > 0){
            if(s.size() == 0){
                ans = -1;
                break;
            }
            auto it = s.lower_bound(page);
            if(it == s.end()){
                page = 1;
                ans++;
            }else{
                int p = *it;
                s.erase(it);
                for(int i = 0; i < g[p].size(); i++){
                    int next = g[p][i];
                    cnt[next]--;
                    if(!cnt[next]) s.insert(next);
                }
                total--;
                page = p;
            }
        }
        cout << ans << "\n";
    }
}
```
{%- include blog_post_comments.html-%}
