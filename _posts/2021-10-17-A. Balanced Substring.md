---
layout: single

title: "A. Balanced Substring"
excerpt: "Educational Codeforces Round 113 (Rated for Div. 2)"

date: 2021-10-17 23:28:52 +0900
last_modified_at: 2021-10-17 23:28:52 +0900 # sitemap.xml에서 사용됨

author_profile: true # 왼쪽부분 프로필을 띄울건지
sidebar:
  nav: "main"

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5 # 투명도

categories: 
  - Codeforces

tags: 
    - Codeforces
    - Educational Codeforces Round 113 (Rated for Div. 2)

use_math: true
comments: true
# table of contents
toc: true # 오른쪽 부분에 목차를 자동 생성해준다.
toc_label: "목차" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---

## 문제 설명  
알파벳 'a'와 'b'로 이루어지고 $n$개의 문자로 이루어진 문자열 $s$가 주어진다. 이 문자열의 index는 $1$ 번부터 $n$번까지로 나타낸다.  
<br>
$s[l;r]$은 index $l$ 부터 $r$까지 string $s$의 부분 문자열이다. 이때 index $r$과 $s$모두 포함한다.  

__Input__  
이 문제는 여러개의 테스트 케이스로 이루어져 있다. 첫번째 줄에는 테스트 케이스의 개수 $t$가 주어진다. $(1 \le t \le 10^3)$

각 테스트케이스의 첫번째 줄에는 시계의 자릿수인 정수 $n$이 주어진다. $(1 \le n \le 100)$  

각 테스트케이스의 두번째 줄에는 $n$자리로 이루어진 문자열이 주어진다. $s_{1}, s_{2}, ....., s_{n}(0 \le s_{1}, s_{2}, ....., s_{n} \le 9)$  

주의사항: 이 시계는 만약 숫자가 $10^{n - 1}$보다 작으면 $0$으로 시작할 수 있다.  

__Output__  
각 테스트 케이스마다 시계에 0이 나타나게 하는 연산의 최소값을 출력한다.  

__Example__  
_input_  
7  
3  
007  
4  
1000  
5  
00000  
3  
103  
4  
2020  
9  
123456789  
30  
001678294039710047203946100020  
  
_output_  
7  
2  
0  
5  
6  
53  
115  

## 문제 접근
__사용한 알고리즘__: 그리디 알고리즘, 구현  
걸린 시간 : 00:06  
맨 뒷자리수에 있는 값을 1 줄이거나 각 자리수에 있는 숫자의 위치를 바꿔서 시계의 값이 000을 보여주게 하는것이 목표인 문제이다.  
값을 1 줄이거나, 각 자리수의 위치를 바꾸는 총 2가지의 연산을 최소로 사용해야한다.
따라서 다음과 같이 생각하는게 좋을것 같다.  
  1. 맨 뒷자리수를 0으로 바꾼다.
  2. 맨 뒷자리수가 0이면 0이 아닌 다른 자릿수와 맨 뒷자리수의 위치를 바꾼다.
  3. 모든 자릿수가 0이 될때까지 1 ~ 2를 반복한다.

1번 과정은 맨 뒷 자리수가 나타나는 숫자만큼 값을 1 줄이는 연산을 하면 된다.  
2번 과정은 0이 아닌 모든 자릿수를 찾아 그 수를 맨 뒤 0과 바꾸는 과정이고, 0이 아닌 자릿수의 개수만큼 이루어진다.  

테스트케이스를 통해서 문제의 답이 도출되는 과정을 살펴보자.  
* str = 2020인 경우 
  1. 맨 뒤 자릿수가 0이기 때문에 1을 줄일 필요가 없다. (ans = 0, str = 2020)  
  2. str[0]이 숫자가 2이기 때문에 맨 뒤자리수와 위치를 바꾼다. (ans += 1, str = 0022)  
  3. 맨 뒤 자릿수가 2이기 때문에 1을 2번 줄인다. (ans += 2, str = 0020)  
  4. str[2]이 숫자가 2이기 때문에 맨 뒤자리수와 위치를 바꾼다. (ans += 1, str = 0002)  
  5. 맨 뒤 자릿수가 2이기 때문에 1을 두번 줄인다. (ans += 2, str = 0000)  
  6. 모든 자릿수가 0이므로 과정을 종료한다. (ans = 0 + 1 + 2 + 1 + 2 == 6)  

* str = 123456789인경우
  1. str[9]가 0이 아니기 때문에 str[o]번 1을 줄이는 연산을 해야한다. (ans += 9, str = 123456780)
  2. str[0]이 숫자가 0이 아니기 때문에 맨 뒤자리수와 위치를 바꾼다. (ans += 1, str = 023456781)
  3. str[9]가 0이 아니기 때문에 str[9]번 1을 줄이는 연산을 해야한다. (ans += 1, str = 023456780)
  4. str[1]이 숫자가 0이 아니기 때문에 맨 뒤자리수와 위치를 바꾼다. (ans += 1, str = 003456782)
  .  
  .  
  .  
  .  
이 행위를 반복하면 답은 $1 * 8 + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) = 53$가 된다.  

## 정답 코드  
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
	int t; cin >> t;
	while(t--){
	    int n; cin >> n;
	    string str; cin >> str;
	    char start = str[0];
	    int a = -1, b = -1;
	    for(int i = 0; i < n; i++){
	        if(str[i] != start){
	            b = i + 1;
	            break;
	        }
	        a = i + 1;
	    }
	    cout << (b == -1 ? -1 : a) << " " << b << "\n";
	}
	return 0;
}
```  
{%- include blog_post_comments.html -%}
